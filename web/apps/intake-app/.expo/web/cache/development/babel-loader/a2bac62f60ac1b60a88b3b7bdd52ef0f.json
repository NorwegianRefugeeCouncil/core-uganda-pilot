{"ast":null,"code":"export var CodeChallengeMethod;\n\n(function (CodeChallengeMethod) {\n  CodeChallengeMethod[\"S256\"] = \"S256\";\n  CodeChallengeMethod[\"Plain\"] = \"plain\";\n})(CodeChallengeMethod || (CodeChallengeMethod = {}));\n\nexport var ResponseType;\n\n(function (ResponseType) {\n  ResponseType[\"Code\"] = \"code\";\n  ResponseType[\"Token\"] = \"token\";\n  ResponseType[\"IdToken\"] = \"id_token\";\n})(ResponseType || (ResponseType = {}));\n\nexport var Prompt;\n\n(function (Prompt) {\n  Prompt[\"None\"] = \"none\";\n  Prompt[\"Login\"] = \"login\";\n  Prompt[\"Consent\"] = \"consent\";\n  Prompt[\"SelectAccount\"] = \"select_account\";\n})(Prompt || (Prompt = {}));","map":{"version":3,"sources":["../src/AuthRequest.types.ts"],"names":[],"mappings":"AAGA,OAAA,IAAY,mBAAZ;;AAAA,CAAA,UAAY,mBAAZ,EAA+B;AAO7B,EAAA,mBAAA,CAAA,MAAA,CAAA,GAAA,MAAA;AAKA,EAAA,mBAAA,CAAA,OAAA,CAAA,GAAA,OAAA;AACD,CAbD,EAAY,mBAAmB,KAAnB,mBAAmB,GAAA,EAAA,CAA/B;;AAqBA,OAAA,IAAY,YAAZ;;AAAA,CAAA,UAAY,YAAZ,EAAwB;AAItB,EAAA,YAAA,CAAA,MAAA,CAAA,GAAA,MAAA;AAIA,EAAA,YAAA,CAAA,OAAA,CAAA,GAAA,OAAA;AAIA,EAAA,YAAA,CAAA,SAAA,CAAA,GAAA,UAAA;AACD,CAbD,EAAY,YAAY,KAAZ,YAAY,GAAA,EAAA,CAAxB;;AAqBA,OAAA,IAAY,MAAZ;;AAAA,CAAA,UAAY,MAAZ,EAAkB;AAMhB,EAAA,MAAA,CAAA,MAAA,CAAA,GAAA,MAAA;AAKA,EAAA,MAAA,CAAA,OAAA,CAAA,GAAA,OAAA;AAKA,EAAA,MAAA,CAAA,SAAA,CAAA,GAAA,SAAA;AAKA,EAAA,MAAA,CAAA,eAAA,CAAA,GAAA,gBAAA;AACD,CAtBD,EAAY,MAAM,KAAN,MAAM,GAAA,EAAA,CAAlB","sourcesContent":["import { CreateURLOptions } from 'expo-linking';\nimport { WebBrowserOpenOptions, WebBrowserWindowFeatures } from 'expo-web-browser';\n\nexport enum CodeChallengeMethod {\n  /**\n   * The default and recommended method for transforming the code verifier.\n   * 1. Convert the code verifier to ASCII.\n   * 2. Create a digest of the string using crypto method SHA256.\n   * 3. Convert the digest to Base64 and URL encode it.\n   */\n  S256 = 'S256',\n  /**\n   * This should not be used.\n   * When used, the code verifier will be sent to the server as-is.\n   */\n  Plain = 'plain',\n}\n\n/**\n * The client informs the authorization server of the\n * desired grant type by using the a response type.\n *\n * [Section 3.1.1](https://tools.ietf.org/html/rfc6749#section-3.1.1)\n */\nexport enum ResponseType {\n  /**\n   * For requesting an authorization code as described by [Section 4.1.1](https://tools.ietf.org/html/rfc6749#section-4.1.1).\n   */\n  Code = 'code',\n  /**\n   * For requesting an access token (implicit grant) as described by [Section 4.2.1](https://tools.ietf.org/html/rfc6749#section-4.2.1).\n   */\n  Token = 'token',\n  /**\n   * A custom registered type for getting an `id_token` from Google OAuth.\n   */\n  IdToken = 'id_token',\n}\n\n/**\n * Should the user be prompted to login or consent again.\n * This can be used to present a dialog for switching accounts after the user has already been logged in.\n *\n * [Section 3.1.2.1](https://openid.net/specs/openid-connect-core-1_0.html#AuthorizationRequest)\n */\nexport enum Prompt {\n  /**\n   * Server must not display any auth or consent UI. Can be used to check for existing auth or consent.\n   * An error is returned if a user isn't already authenticated or the client doesn't have pre-configured consent for the requested claims, or does not fulfill other conditions for processing the request.\n   * The error code will typically be `login_required`, `interaction_required`, or another code defined in [Section 3.1.2.6](https://openid.net/specs/openid-connect-core-1_0.html#AuthError).\n   */\n  None = 'none',\n  /**\n   * The server should prompt the user to reauthenticate.\n   * If it cannot reauthenticate the End-User, it must return an error, typically `login_required`.\n   */\n  Login = 'login',\n  /**\n   * Server should prompt the user for consent before returning information to the client.\n   * If it cannot obtain consent, it must return an error, typically `consent_required`.\n   */\n  Consent = 'consent',\n  /**\n   * Server should prompt the user to select an account. Can be used to switch accounts.\n   * If it can't obtain an account selection choice made by the user, it must return an error, typically `account_selection_required`.\n   */\n  SelectAccount = 'select_account',\n}\n\n/**\n * Options for the prompt window / web browser.\n * This can be used to configure how the web browser should look and behave.\n */\nexport type AuthRequestPromptOptions = Omit<WebBrowserOpenOptions, 'windowFeatures'> & {\n  /**\n   * URL to open when prompting the user. This should be defined internally.\n   */\n  url?: string;\n  /**\n   * Should the authentication request use the Expo proxy service `auth.expo.io`.\n   * Default: `false`.\n   */\n  useProxy?: boolean;\n  /**\n   * URL options to be used when creating the redirect URL for the auth proxy.\n   */\n  proxyOptions?: Omit<CreateURLOptions, 'queryParams'> & { path?: string };\n  /**\n   * **Web:** features to use with `window.open()`\n   */\n  windowFeatures?: WebBrowserWindowFeatures;\n};\n\n/**\n * Represents an OAuth authorization request as JSON.\n */\nexport interface AuthRequestConfig {\n  /**\n   * Specifies what is returned from the authorization server.\n   *\n   * [Section 3.1.1](https://tools.ietf.org/html/rfc6749#section-3.1.1)\n   *\n   * @default ResponseType.Code\n   */\n  responseType?: ResponseType | string;\n  /**\n   * A unique string representing the registration information provided by the client.\n   * The client identifier is not a secret; it is exposed to the resource owner and shouldn't be used\n   * alone for client authentication.\n   *\n   * The client identifier is unique to the authorization server.\n   *\n   * [Section 2.2](https://tools.ietf.org/html/rfc6749#section-2.2)\n   */\n  clientId: string;\n  /**\n   * After completing an interaction with a resource owner the\n   * server will redirect to this URI. Learn more about [linking in Expo](https://docs.expo.io/versions/latest/workflow/linking/).\n   *\n   * [Section 3.1.2](https://tools.ietf.org/html/rfc6749#section-3.1.2)\n   */\n  redirectUri: string;\n  /**\n   * List of strings to request access to.\n   *\n   * [Section 3.3](https://tools.ietf.org/html/rfc6749#section-3.3)\n   */\n  scopes?: string[];\n  /**\n   * Client secret supplied by an auth provider.\n   * There is no secure way to store this on the client.\n   *\n   * [Section 2.3.1](https://tools.ietf.org/html/rfc6749#section-2.3.1)\n   */\n  clientSecret?: string;\n  /**\n   * Method used to generate the code challenge.\n   * Defaults to `S256`. You should never use `Plain` as it's not good enough for secure verification.\n   */\n  codeChallengeMethod?: CodeChallengeMethod;\n  /**\n   * Derived from the code verifier by using the `CodeChallengeMethod`.\n   *\n   * [Section 4.2](https://tools.ietf.org/html/rfc7636#section-4.2)\n   */\n  codeChallenge?: string;\n  /**\n   * Informs the server if the user should be prompted to login or consent again.\n   * This can be used to present a dialog for switching accounts after the user has already been logged in.\n   *\n   * [Section 3.1.2.1](https://openid.net/specs/openid-connect-core-1_0.html#AuthorizationRequest)\n   */\n  prompt?: Prompt;\n  /**\n   * Used for protection against [Cross-Site Request Forgery](https://tools.ietf.org/html/rfc6749#section-10.12).\n   */\n  state?: string;\n  /**\n   * Extra query params that'll be added to the query string.\n   */\n  extraParams?: Record<string, string>;\n  /**\n   * Should use [Proof Key for Code Exchange](https://oauth.net/2/pkce/).\n   * Defaults to true.\n   */\n  usePKCE?: boolean;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}