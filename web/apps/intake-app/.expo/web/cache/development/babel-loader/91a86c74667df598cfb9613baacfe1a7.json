{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport invariant from 'invariant';\nimport { requestAsync } from \"./Fetch\";\nexport function issuerWithWellKnownUrl(issuer) {\n  return issuer + \"/.well-known/openid-configuration\";\n}\nexport function fetchDiscoveryAsync(issuer) {\n  var json;\n  return _regeneratorRuntime.async(function fetchDiscoveryAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return _regeneratorRuntime.awrap(requestAsync(issuerWithWellKnownUrl(issuer), {\n            dataType: 'json',\n            method: 'GET'\n          }));\n\n        case 2:\n          json = _context.sent;\n          return _context.abrupt(\"return\", {\n            discoveryDocument: json,\n            authorizationEndpoint: json.authorization_endpoint,\n            tokenEndpoint: json.token_endpoint,\n            revocationEndpoint: json.revocation_endpoint,\n            userInfoEndpoint: json.userinfo_endpoint,\n            endSessionEndpoint: json.end_session_endpoint,\n            registrationEndpoint: json.registration_endpoint\n          });\n\n        case 4:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function resolveDiscoveryAsync(issuerOrDiscovery) {\n  return _regeneratorRuntime.async(function resolveDiscoveryAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          invariant(issuerOrDiscovery && !['number', 'boolean'].includes(typeof issuerOrDiscovery), 'Expected a valid discovery object or issuer URL');\n\n          if (!(typeof issuerOrDiscovery === 'string')) {\n            _context2.next = 5;\n            break;\n          }\n\n          _context2.next = 4;\n          return _regeneratorRuntime.awrap(fetchDiscoveryAsync(issuerOrDiscovery));\n\n        case 4:\n          return _context2.abrupt(\"return\", _context2.sent);\n\n        case 5:\n          return _context2.abrupt(\"return\", issuerOrDiscovery);\n\n        case 6:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}","map":{"version":3,"sources":["../src/Discovery.ts"],"names":[],"mappings":";AAAA,OAAO,SAAP,MAAsB,WAAtB;AAEA,SAAS,YAAT;AAoMA,OAAM,SAAU,sBAAV,CAAiC,MAAjC,EAA+C;AACnD,SAAU,MAAV;AACD;AAED,OAAO,SAAe,mBAAf,CAAmC,MAAnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2CACc,YAAY,CAAmB,sBAAsB,CAAC,MAAD,CAAzC,EAAmD;AAChF,YAAA,QAAQ,EAAE,MADsE;AAEhF,YAAA,MAAM,EAAE;AAFwE,WAAnD,CAD1B;;AAAA;AACC,UAAA,IADD;AAAA,2CAME;AACL,YAAA,iBAAiB,EAAE,IADd;AAEL,YAAA,qBAAqB,EAAE,IAAI,CAAC,sBAFvB;AAGL,YAAA,aAAa,EAAE,IAAI,CAAC,cAHf;AAIL,YAAA,kBAAkB,EAAE,IAAI,CAAC,mBAJpB;AAKL,YAAA,gBAAgB,EAAE,IAAI,CAAC,iBALlB;AAML,YAAA,kBAAkB,EAAE,IAAI,CAAC,oBANpB;AAOL,YAAA,oBAAoB,EAAE,IAAI,CAAC;AAPtB,WANF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsBP,OAAO,SAAe,qBAAf,CACL,iBADK;AAAA;AAAA;AAAA;AAAA;AAGL,UAAA,SAAS,CACP,iBAAiB,IAAI,CAAC,CAAC,QAAD,EAAW,SAAX,EAAsB,QAAtB,CAA+B,OAAO,iBAAtC,CADf,EAEP,iDAFO,CAAT;;AAHK,gBAOD,OAAO,iBAAP,KAA6B,QAP5B;AAAA;AAAA;AAAA;;AAAA;AAAA,2CAQU,mBAAmB,CAAC,iBAAD,CAR7B;;AAAA;AAAA;;AAAA;AAAA,4CAUE,iBAVF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA","sourcesContent":["import invariant from 'invariant';\n\nimport { requestAsync } from './Fetch';\n\n/**\n * URL using the `https` scheme with no query or fragment component that the OP asserts as its Issuer Identifier.\n */\nexport type Issuer = string;\n\ntype ProviderMetadataEndpoints = {\n  issuer?: Issuer;\n  /**\n   * URL of the OP's OAuth 2.0 Authorization Endpoint.\n   */\n  authorization_endpoint: string;\n  /**\n   * URL of the OP's OAuth 2.0 Token Endpoint.\n   * This is required unless only the Implicit Flow is used.\n   */\n  token_endpoint: string;\n  /**\n   * URL of the OP's UserInfo Endpoint.\n   */\n  userinfo_endpoint?: string;\n\n  revocation_endpoint?: string;\n  registration_endpoint?: string;\n  end_session_endpoint?: string;\n  introspection_endpoint?: string;\n  device_authorization_endpoint?: string;\n};\n\n/**\n * OpenID Providers have metadata describing their configuration.\n * [ProviderMetadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata)\n */\nexport type ProviderMetadata = Record<string, string | boolean | string[]> &\n  ProviderMetadataEndpoints & {\n    /**\n     * URL of the OP's JSON Web Key Set [JWK](https://openid.net/specs/openid-connect-discovery-1_0.html#JWK) document.\n     */\n    jwks_uri?: string;\n    /**\n     * JSON array containing a list of the OAuth 2.0 [RFC6749](https://openid.net/specs/openid-connect-discovery-1_0.html#RFC6749) scope values that this server supports.\n     */\n    scopes_supported?: string[];\n    /**\n     * JSON array containing a list of the OAuth 2.0 `response_type` values that this OP supports.\n     * Dynamic OpenID Providers must support the `code`, `id_token`, and the `token` `id_token` Response Type values\n     */\n    response_types_supported?: string[];\n    /**\n     * JSON array containing a list of the OAuth 2.0 `response_mode` values that this OP supports,\n     * as specified in [OAuth 2.0 Multiple Response Type Encoding Practices](https://openid.net/specs/openid-connect-discovery-1_0.html#OAuth.Responses).\n     * If omitted, the default for Dynamic OpenID Providers is `[\"query\", \"fragment\"]`.\n     */\n    response_modes_supported?: string[];\n    /**\n     * JSON array containing a list of the OAuth 2.0 Grant Type values that this OP supports.\n     * Dynamic OpenID Providers MUST support the authorization_code and implicit Grant Type values and MAY support other Grant Types.\n     * If omitted, the default value is [\"authorization_code\", \"implicit\"].\n     */\n    grant_types_supported?: string[];\n    /**\n     * JSON array containing a list of the JWS signing algorithms (alg values) supported by the OP for the ID Token to encode the Claims in a JWT.\n     * The algorithm RS256 MUST be included.\n     */\n    id_token_signing_alg_values_supported?: string[];\n    /**\n     * JSON array containing a list of the Subject Identifier types that this OP supports.\n     * Valid types include `pairwise` and `public`.\n     */\n    subject_types_supported?: string[];\n    /**\n     * A list of Client authentication methods supported by this Token Endpoint.\n     * If omitted, the default is `['client_secret_basic']`\n     */\n    token_endpoint_auth_methods_supported?: (\n      | 'client_secret_post'\n      | 'client_secret_basic'\n      | 'client_secret_jwt'\n      | 'private_key_jwt'\n      // Allows for extensions\n      | string\n    )[];\n    /**\n     *  a list of the `display` parameter values that the OpenID Provider supports.\n     */\n    display_values_supported?: string[];\n    /**\n     * a list of the Claim Types that the OpenID Provider supports.\n     */\n    claim_types_supported?: string[];\n    /**\n     * a list of the Claim Names of the Claims that the OpenID Provider may be able to supply values for.\n     * Note that for privacy or other reasons, this might not be an exhaustive list.\n     */\n    claims_supported?: string[];\n    /**\n     * URL of a page containing human-readable information that developers might want or need to know when using the OpenID Provider.\n     * In particular, if the OpenID Provider does not support Dynamic Client Registration, then information on how to register Clients needs to be provided in this documentation.\n     */\n    service_documentation?: string;\n    /**\n     * Languages and scripts supported for values in Claims being returned.\n     */\n    claims_locales_supported?: string[];\n    /**\n     * Languages and scripts supported for the user interface,\n     * represented as a JSON array of [BCP47](https://openid.net/specs/openid-connect-discovery-1_0.html#RFC5646) language tag values.\n     */\n    ui_locales_supported?: string[];\n    /**\n     * Boolean value specifying whether the OP supports use of the claims parameter, with `true` indicating support.\n     * If omitted, the default value is `false`.\n     */\n    claims_parameter_supported?: boolean;\n    /**\n     * Boolean value specifying whether the OP supports use of the request parameter, with `true` indicating support.\n     * If omitted, the default value is `false`.\n     */\n    request_parameter_supported?: boolean;\n    /**\n     * Whether the OP supports use of the `request_uri` parameter, with `true` indicating support.\n     * If omitted, the default value is `true`.\n     */\n    request_uri_parameter_supported?: boolean;\n    /**\n     * Whether the OP requires any `request_uri` values used to be pre-registered using the `request_uris` registration parameter.\n     * Pre-registration is required when the value is `true`.\n     * If omitted, the default value is `false`.\n     */\n    require_request_uri_registration?: boolean;\n    /**\n     * URL that the OpenID Provider provides to the person registering the Client to read about the OP's requirements on how the Relying Party can use the data provided by the OP. The registration process SHOULD display this URL to the person registering the Client if it is given.\n     */\n    op_policy_uri?: string;\n    /**\n     * URL that the OpenID Provider provides to the person registering the Client to read about OpenID Provider's terms of service.\n     * The registration process should display this URL to the person registering the Client if it is given.\n     */\n    op_tos_uri?: string;\n\n    code_challenge_methods_supported?: ('plain' | 'S256')[];\n    check_session_iframe?: string;\n    backchannel_logout_supported?: boolean;\n    backchannel_logout_session_supported?: boolean;\n    frontchannel_logout_supported?: boolean;\n    frontchannel_logout_session_supported?: boolean;\n  };\n\nexport interface DiscoveryDocument {\n  /**\n   * Used to interact with the resource owner and obtain an authorization grant.\n   *\n   * [Section 3.1](https://tools.ietf.org/html/rfc6749#section-3.1)\n   */\n  authorizationEndpoint?: string;\n  /**\n   * Used by the client to obtain an access token by presenting its authorization grant or refresh token.\n   * The token endpoint is used with every authorization grant except for the\n   * implicit grant type (since an access token is issued directly).\n   *\n   * [Section 3.2](https://tools.ietf.org/html/rfc6749#section-3.2)\n   */\n  tokenEndpoint?: string;\n  /**\n   * The spec requires a revocation endpoint but some providers (like Spotify) do not support one.\n   *\n   * [Section 2.1](https://tools.ietf.org/html/rfc7009#section-2.1)\n   */\n  revocationEndpoint?: string;\n  /**\n   * URL of the OP's UserInfo Endpoint.\n   *\n   * [UserInfo](https://openid.net/specs/openid-connect-core-1_0.html#UserInfo)\n   */\n  userInfoEndpoint?: string;\n  /**\n   * URL at the OP to which an RP can perform a redirect to request that the End-User be logged out at the OP.\n   *\n   * [OPMetadata](https://openid.net/specs/openid-connect-session-1_0-17.html#OPMetadata)\n   */\n  endSessionEndpoint?: string;\n  /**\n   * URL of the OP's [Dynamic Client Registration](https://openid.net/specs/openid-connect-discovery-1_0.html#OpenID.Registration) Endpoint.\n   */\n  registrationEndpoint?: string;\n\n  discoveryDocument?: ProviderMetadata;\n}\n\nexport type IssuerOrDiscovery = Issuer | DiscoveryDocument;\n\n/**\n * Append the well known resources path and OpenID connect discovery document path to a URL\n * https://tools.ietf.org/html/rfc5785\n */\nexport function issuerWithWellKnownUrl(issuer: Issuer): string {\n  return `${issuer}/.well-known/openid-configuration`;\n}\n\nexport async function fetchDiscoveryAsync(issuer: Issuer): Promise<DiscoveryDocument> {\n  const json = await requestAsync<ProviderMetadata>(issuerWithWellKnownUrl(issuer), {\n    dataType: 'json',\n    method: 'GET',\n  });\n\n  return {\n    discoveryDocument: json,\n    authorizationEndpoint: json.authorization_endpoint,\n    tokenEndpoint: json.token_endpoint,\n    revocationEndpoint: json.revocation_endpoint,\n    userInfoEndpoint: json.userinfo_endpoint,\n    endSessionEndpoint: json.end_session_endpoint,\n    registrationEndpoint: json.registration_endpoint,\n  };\n}\n\n/**\n * Utility method for resolving the discovery document from an issuer or object.\n *\n * @param issuerOrDiscovery\n */\nexport async function resolveDiscoveryAsync(\n  issuerOrDiscovery: IssuerOrDiscovery\n): Promise<DiscoveryDocument> {\n  invariant(\n    issuerOrDiscovery && !['number', 'boolean'].includes(typeof issuerOrDiscovery),\n    'Expected a valid discovery object or issuer URL'\n  );\n  if (typeof issuerOrDiscovery === 'string') {\n    return await fetchDiscoveryAsync(issuerOrDiscovery);\n  }\n  return issuerOrDiscovery;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}