{"ast":null,"code":"import _get from \"@babel/runtime/helpers/get\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport invariant from 'invariant';\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport * as Base64 from \"./Base64\";\nimport { TokenError } from \"./Errors\";\nimport { requestAsync } from \"./Fetch\";\nimport { GrantType } from \"./TokenRequest.types\";\nexport function getCurrentTimeInSeconds() {\n  return Math.floor(Date.now() / 1000);\n}\nexport var TokenResponse = function () {\n  function TokenResponse(response) {\n    var _response$tokenType, _response$issuedAt;\n\n    _classCallCheck(this, TokenResponse);\n\n    this.accessToken = response.accessToken;\n    this.tokenType = (_response$tokenType = response.tokenType) != null ? _response$tokenType : 'bearer';\n    this.expiresIn = response.expiresIn;\n    this.refreshToken = response.refreshToken;\n    this.scope = response.scope;\n    this.state = response.state;\n    this.idToken = response.idToken;\n    this.issuedAt = (_response$issuedAt = response.issuedAt) != null ? _response$issuedAt : getCurrentTimeInSeconds();\n  }\n\n  _createClass(TokenResponse, [{\n    key: \"applyResponseConfig\",\n    value: function applyResponseConfig(response) {\n      var _response$accessToken, _ref, _response$tokenType2, _response$expiresIn, _response$refreshToke, _response$scope, _response$state, _response$idToken, _ref2, _response$issuedAt2;\n\n      this.accessToken = (_response$accessToken = response.accessToken) != null ? _response$accessToken : this.accessToken;\n      this.tokenType = (_ref = (_response$tokenType2 = response.tokenType) != null ? _response$tokenType2 : this.tokenType) != null ? _ref : 'bearer';\n      this.expiresIn = (_response$expiresIn = response.expiresIn) != null ? _response$expiresIn : this.expiresIn;\n      this.refreshToken = (_response$refreshToke = response.refreshToken) != null ? _response$refreshToke : this.refreshToken;\n      this.scope = (_response$scope = response.scope) != null ? _response$scope : this.scope;\n      this.state = (_response$state = response.state) != null ? _response$state : this.state;\n      this.idToken = (_response$idToken = response.idToken) != null ? _response$idToken : this.idToken;\n      this.issuedAt = (_ref2 = (_response$issuedAt2 = response.issuedAt) != null ? _response$issuedAt2 : this.issuedAt) != null ? _ref2 : getCurrentTimeInSeconds();\n    }\n  }, {\n    key: \"getRequestConfig\",\n    value: function getRequestConfig() {\n      return {\n        accessToken: this.accessToken,\n        idToken: this.idToken,\n        refreshToken: this.refreshToken,\n        scope: this.scope,\n        state: this.state,\n        tokenType: this.tokenType,\n        issuedAt: this.issuedAt,\n        expiresIn: this.expiresIn\n      };\n    }\n  }, {\n    key: \"refreshAsync\",\n    value: function refreshAsync(config, discovery) {\n      var _response$refreshToke2;\n\n      var request, response, json;\n      return _regeneratorRuntime.async(function refreshAsync$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              request = new RefreshTokenRequest(_objectSpread(_objectSpread({}, config), {}, {\n                refreshToken: this.refreshToken\n              }));\n              _context.next = 3;\n              return _regeneratorRuntime.awrap(request.performAsync(discovery));\n\n            case 3:\n              response = _context.sent;\n              response.refreshToken = (_response$refreshToke2 = response.refreshToken) != null ? _response$refreshToke2 : this.refreshToken;\n              json = response.getRequestConfig();\n              this.applyResponseConfig(json);\n              return _context.abrupt(\"return\", this);\n\n            case 8:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"shouldRefresh\",\n    value: function shouldRefresh() {\n      return !(TokenResponse.isTokenFresh(this) || !this.refreshToken);\n    }\n  }], [{\n    key: \"isTokenFresh\",\n    value: function isTokenFresh(token) {\n      var secondsMargin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 60 * 10 * -1;\n\n      if (!token) {\n        return false;\n      }\n\n      if (token.expiresIn) {\n        var now = getCurrentTimeInSeconds();\n        return now < token.issuedAt + token.expiresIn + secondsMargin;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"fromQueryParams\",\n    value: function fromQueryParams(params) {\n      return new TokenResponse({\n        accessToken: params.access_token,\n        refreshToken: params.refresh_token,\n        scope: params.scope,\n        state: params.state,\n        idToken: params.id_token,\n        tokenType: params.token_type,\n        expiresIn: params.expires_in,\n        issuedAt: params.issued_at\n      });\n    }\n  }]);\n\n  return TokenResponse;\n}();\n\nvar Request = function () {\n  function Request(request) {\n    _classCallCheck(this, Request);\n\n    this.request = request;\n  }\n\n  _createClass(Request, [{\n    key: \"performAsync\",\n    value: function performAsync(discovery) {\n      return _regeneratorRuntime.async(function performAsync$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              throw new Error('performAsync must be extended');\n\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }, {\n    key: \"getRequestConfig\",\n    value: function getRequestConfig() {\n      throw new Error('getRequestConfig must be extended');\n    }\n  }, {\n    key: \"getQueryBody\",\n    value: function getQueryBody() {\n      throw new Error('getQueryBody must be extended');\n    }\n  }]);\n\n  return Request;\n}();\n\nvar TokenRequest = function (_Request) {\n  _inherits(TokenRequest, _Request);\n\n  var _super = _createSuper(TokenRequest);\n\n  function TokenRequest(request, grantType) {\n    var _this;\n\n    _classCallCheck(this, TokenRequest);\n\n    _this = _super.call(this, request);\n    _this.grantType = grantType;\n    _this.clientId = request.clientId;\n    _this.clientSecret = request.clientSecret;\n    _this.extraParams = request.extraParams;\n    _this.scopes = request.scopes;\n    return _this;\n  }\n\n  _createClass(TokenRequest, [{\n    key: \"getHeaders\",\n    value: function getHeaders() {\n      var headers = {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      };\n\n      if (typeof this.clientSecret !== 'undefined') {\n        var encodedClientId = encodeURIComponent(this.clientId);\n        var encodedClientSecret = encodeURIComponent(this.clientSecret);\n        var credentials = encodedClientId + \":\" + encodedClientSecret;\n        var basicAuth = Base64.encodeNoWrap(credentials);\n        headers.Authorization = \"Basic \" + basicAuth;\n      }\n\n      return headers;\n    }\n  }, {\n    key: \"performAsync\",\n    value: function performAsync(discovery) {\n      var response;\n      return _regeneratorRuntime.async(function performAsync$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              invariant(discovery.tokenEndpoint, \"Cannot invoke `performAsync()` without a valid tokenEndpoint\");\n              _context3.next = 3;\n              return _regeneratorRuntime.awrap(requestAsync(discovery.tokenEndpoint, {\n                dataType: 'json',\n                method: 'POST',\n                headers: this.getHeaders(),\n                body: this.getQueryBody()\n              }));\n\n            case 3:\n              response = _context3.sent;\n\n              if (!('error' in response)) {\n                _context3.next = 6;\n                break;\n              }\n\n              throw new TokenError(response);\n\n            case 6:\n              return _context3.abrupt(\"return\", new TokenResponse({\n                accessToken: response.access_token,\n                tokenType: response.token_type,\n                expiresIn: response.expires_in,\n                refreshToken: response.refresh_token,\n                scope: response.scope,\n                idToken: response.id_token,\n                issuedAt: response.issued_at\n              }));\n\n            case 7:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"getQueryBody\",\n    value: function getQueryBody() {\n      var queryBody = {\n        grant_type: this.grantType\n      };\n\n      if (!this.clientSecret) {\n        queryBody.client_id = this.clientId;\n      }\n\n      if (this.scopes) {\n        queryBody.scope = this.scopes.join(' ');\n      }\n\n      if (this.extraParams) {\n        for (var extra in this.extraParams) {\n          if (extra in this.extraParams && !(extra in queryBody)) {\n            queryBody[extra] = this.extraParams[extra];\n          }\n        }\n      }\n\n      return queryBody;\n    }\n  }]);\n\n  return TokenRequest;\n}(Request);\n\nexport var AccessTokenRequest = function (_TokenRequest) {\n  _inherits(AccessTokenRequest, _TokenRequest);\n\n  var _super2 = _createSuper(AccessTokenRequest);\n\n  function AccessTokenRequest(options) {\n    var _this2;\n\n    _classCallCheck(this, AccessTokenRequest);\n\n    invariant(options.redirectUri, \"`AccessTokenRequest` requires a valid `redirectUri` (it must also match the one used in the auth request). Example: \" + Platform.select({\n      web: 'https://yourwebsite.com/redirect',\n      default: 'myapp://redirect'\n    }));\n    invariant(options.code, \"`AccessTokenRequest` requires a valid authorization `code`. This is what's received from the authorization server after an auth request.\");\n    _this2 = _super2.call(this, options, GrantType.AuthorizationCode);\n    _this2.code = options.code;\n    _this2.redirectUri = options.redirectUri;\n    return _this2;\n  }\n\n  _createClass(AccessTokenRequest, [{\n    key: \"getQueryBody\",\n    value: function getQueryBody() {\n      var queryBody = _get(_getPrototypeOf(AccessTokenRequest.prototype), \"getQueryBody\", this).call(this);\n\n      if (this.redirectUri) {\n        queryBody.redirect_uri = this.redirectUri;\n      }\n\n      if (this.code) {\n        queryBody.code = this.code;\n      }\n\n      return queryBody;\n    }\n  }, {\n    key: \"getRequestConfig\",\n    value: function getRequestConfig() {\n      return {\n        clientId: this.clientId,\n        clientSecret: this.clientSecret,\n        grantType: this.grantType,\n        code: this.code,\n        redirectUri: this.redirectUri,\n        extraParams: this.extraParams,\n        scopes: this.scopes\n      };\n    }\n  }]);\n\n  return AccessTokenRequest;\n}(TokenRequest);\nexport var RefreshTokenRequest = function (_TokenRequest2) {\n  _inherits(RefreshTokenRequest, _TokenRequest2);\n\n  var _super3 = _createSuper(RefreshTokenRequest);\n\n  function RefreshTokenRequest(options) {\n    var _this3;\n\n    _classCallCheck(this, RefreshTokenRequest);\n\n    invariant(options.refreshToken, \"`RefreshTokenRequest` requires a valid `refreshToken`.\");\n    _this3 = _super3.call(this, options, GrantType.RefreshToken);\n    _this3.refreshToken = options.refreshToken;\n    return _this3;\n  }\n\n  _createClass(RefreshTokenRequest, [{\n    key: \"getQueryBody\",\n    value: function getQueryBody() {\n      var queryBody = _get(_getPrototypeOf(RefreshTokenRequest.prototype), \"getQueryBody\", this).call(this);\n\n      if (this.refreshToken) {\n        queryBody.refresh_token = this.refreshToken;\n      }\n\n      return queryBody;\n    }\n  }, {\n    key: \"getRequestConfig\",\n    value: function getRequestConfig() {\n      return {\n        clientId: this.clientId,\n        clientSecret: this.clientSecret,\n        grantType: this.grantType,\n        refreshToken: this.refreshToken,\n        extraParams: this.extraParams,\n        scopes: this.scopes\n      };\n    }\n  }]);\n\n  return RefreshTokenRequest;\n}(TokenRequest);\nexport var RevokeTokenRequest = function (_Request2) {\n  _inherits(RevokeTokenRequest, _Request2);\n\n  var _super4 = _createSuper(RevokeTokenRequest);\n\n  function RevokeTokenRequest(request) {\n    var _this4;\n\n    _classCallCheck(this, RevokeTokenRequest);\n\n    _this4 = _super4.call(this, request);\n    invariant(request.token, \"`RevokeTokenRequest` requires a valid `token` to revoke.\");\n    _this4.clientId = request.clientId;\n    _this4.clientSecret = request.clientSecret;\n    _this4.token = request.token;\n    _this4.tokenTypeHint = request.tokenTypeHint;\n    return _this4;\n  }\n\n  _createClass(RevokeTokenRequest, [{\n    key: \"getHeaders\",\n    value: function getHeaders() {\n      var headers = {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      };\n\n      if (typeof this.clientSecret !== 'undefined' && this.clientId) {\n        var encodedClientId = encodeURIComponent(this.clientId);\n        var encodedClientSecret = encodeURIComponent(this.clientSecret);\n        var credentials = encodedClientId + \":\" + encodedClientSecret;\n        var basicAuth = Base64.encodeNoWrap(credentials);\n        headers.Authorization = \"Basic \" + basicAuth;\n      }\n\n      return headers;\n    }\n  }, {\n    key: \"performAsync\",\n    value: function performAsync(discovery) {\n      return _regeneratorRuntime.async(function performAsync$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              invariant(discovery.revocationEndpoint, \"Cannot invoke `performAsync()` without a valid revocationEndpoint\");\n              _context4.next = 3;\n              return _regeneratorRuntime.awrap(requestAsync(discovery.revocationEndpoint, {\n                method: 'POST',\n                headers: this.getHeaders(),\n                body: this.getQueryBody()\n              }));\n\n            case 3:\n              return _context4.abrupt(\"return\", true);\n\n            case 4:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"getRequestConfig\",\n    value: function getRequestConfig() {\n      return {\n        clientId: this.clientId,\n        clientSecret: this.clientSecret,\n        token: this.token,\n        tokenTypeHint: this.tokenTypeHint\n      };\n    }\n  }, {\n    key: \"getQueryBody\",\n    value: function getQueryBody() {\n      var queryBody = {\n        token: this.token\n      };\n\n      if (this.tokenTypeHint) {\n        queryBody.token_type_hint = this.tokenTypeHint;\n      }\n\n      if (this.clientId) {\n        queryBody.client_id = this.clientId;\n      }\n\n      if (this.clientSecret) {\n        queryBody.client_secret = this.clientSecret;\n      }\n\n      return queryBody;\n    }\n  }]);\n\n  return RevokeTokenRequest;\n}(Request);\nexport function exchangeCodeAsync(config, discovery) {\n  var request = new AccessTokenRequest(config);\n  return request.performAsync(discovery);\n}\nexport function refreshAsync(config, discovery) {\n  var request = new RefreshTokenRequest(config);\n  return request.performAsync(discovery);\n}\nexport function revokeAsync(config, discovery) {\n  var request = new RevokeTokenRequest(config);\n  return request.performAsync(discovery);\n}\nexport function fetchUserInfoAsync(config, discovery) {\n  if (!discovery.userInfoEndpoint) {\n    throw new Error('User info endpoint is not defined in the service config discovery document');\n  }\n\n  return requestAsync(discovery.userInfoEndpoint, {\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      Authorization: \"Bearer \" + config.accessToken\n    },\n    dataType: 'json',\n    method: 'GET'\n  });\n}","map":{"version":3,"sources":["../src/TokenRequest.ts"],"names":[],"mappings":"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","sourcesContent":["import invariant from 'invariant';\nimport { Platform } from 'react-native';\n\nimport * as Base64 from './Base64';\nimport * as ServiceConfig from './Discovery';\nimport { ResponseErrorConfig, TokenError } from './Errors';\nimport { Headers, requestAsync } from './Fetch';\nimport {\n  AccessTokenRequestConfig,\n  GrantType,\n  RefreshTokenRequestConfig,\n  RevokeTokenRequestConfig,\n  ServerTokenResponseConfig,\n  TokenRequestConfig,\n  TokenResponseConfig,\n  TokenType,\n  TokenTypeHint,\n} from './TokenRequest.types';\n\n/**\n * Returns the current time in seconds.\n */\nexport function getCurrentTimeInSeconds(): number {\n  return Math.floor(Date.now() / 1000);\n}\n\n/**\n * Token Response.\n *\n * [Section 5.1](https://tools.ietf.org/html/rfc6749#section-5.1)\n */\nexport class TokenResponse implements TokenResponseConfig {\n  /**\n   * Determines whether a token refresh request must be made to refresh the tokens\n   *\n   * @param token\n   * @param secondsMargin\n   */\n  static isTokenFresh(\n    token: Pick<TokenResponse, 'expiresIn' | 'issuedAt'>,\n    /**\n     * -10 minutes in seconds\n     */\n    secondsMargin: number = 60 * 10 * -1\n  ): boolean {\n    if (!token) {\n      return false;\n    }\n    if (token.expiresIn) {\n      const now = getCurrentTimeInSeconds();\n      return now < token.issuedAt + token.expiresIn + secondsMargin;\n    }\n    // if there is no expiration time but we have an access token, it is assumed to never expire\n    return true;\n  }\n  /**\n   * Creates a `TokenResponse` from query parameters returned from an `AuthRequest`.\n   *\n   * @param params\n   */\n  static fromQueryParams(params: Record<string, string>): TokenResponse {\n    return new TokenResponse({\n      accessToken: params.access_token,\n      refreshToken: params.refresh_token,\n      scope: params.scope,\n      state: params.state,\n      idToken: params.id_token,\n      // @ts-ignore: Expected specific string\n      tokenType: params.token_type,\n      // @ts-ignore: Expected number\n      expiresIn: params.expires_in,\n      // @ts-ignore: Expected number\n      issuedAt: params.issued_at,\n    });\n  }\n\n  accessToken: string;\n  tokenType: TokenType;\n  expiresIn?: number;\n  refreshToken?: string;\n  scope?: string;\n  state?: string;\n  idToken?: string;\n  issuedAt: number;\n\n  constructor(response: TokenResponseConfig) {\n    this.accessToken = response.accessToken;\n    this.tokenType = response.tokenType ?? 'bearer';\n    this.expiresIn = response.expiresIn;\n    this.refreshToken = response.refreshToken;\n    this.scope = response.scope;\n    this.state = response.state;\n    this.idToken = response.idToken;\n    this.issuedAt = response.issuedAt ?? getCurrentTimeInSeconds();\n  }\n\n  private applyResponseConfig(response: TokenResponseConfig) {\n    this.accessToken = response.accessToken ?? this.accessToken;\n    this.tokenType = response.tokenType ?? this.tokenType ?? 'bearer';\n    this.expiresIn = response.expiresIn ?? this.expiresIn;\n    this.refreshToken = response.refreshToken ?? this.refreshToken;\n    this.scope = response.scope ?? this.scope;\n    this.state = response.state ?? this.state;\n    this.idToken = response.idToken ?? this.idToken;\n    this.issuedAt = response.issuedAt ?? this.issuedAt ?? getCurrentTimeInSeconds();\n  }\n\n  getRequestConfig(): TokenResponseConfig {\n    return {\n      accessToken: this.accessToken,\n      idToken: this.idToken,\n      refreshToken: this.refreshToken,\n      scope: this.scope,\n      state: this.state,\n      tokenType: this.tokenType,\n      issuedAt: this.issuedAt,\n      expiresIn: this.expiresIn,\n    };\n  }\n\n  async refreshAsync(\n    config: Omit<TokenRequestConfig, 'grantType' | 'refreshToken'>,\n    discovery: Pick<ServiceConfig.DiscoveryDocument, 'tokenEndpoint'>\n  ): Promise<TokenResponse> {\n    const request = new RefreshTokenRequest({\n      ...config,\n      refreshToken: this.refreshToken,\n    });\n    const response = await request.performAsync(discovery);\n    // Custom: reuse the refresh token if one wasn't returned\n    response.refreshToken = response.refreshToken ?? this.refreshToken;\n    const json = response.getRequestConfig();\n    this.applyResponseConfig(json);\n    return this;\n  }\n\n  shouldRefresh(): boolean {\n    // no refresh token available and token has expired\n    return !(TokenResponse.isTokenFresh(this) || !this.refreshToken);\n  }\n}\n\nclass Request<T, B> {\n  constructor(protected request: T) {}\n\n  async performAsync(discovery: ServiceConfig.DiscoveryDocument): Promise<B> {\n    throw new Error('performAsync must be extended');\n  }\n\n  getRequestConfig(): T {\n    throw new Error('getRequestConfig must be extended');\n  }\n\n  getQueryBody(): Record<string, string> {\n    throw new Error('getQueryBody must be extended');\n  }\n}\n\n/**\n * A generic token request.\n */\nclass TokenRequest<T extends TokenRequestConfig> extends Request<T, TokenResponse> {\n  readonly clientId: string;\n  readonly clientSecret?: string;\n  readonly scopes?: string[];\n  readonly extraParams?: Record<string, string>;\n\n  constructor(request, public grantType: GrantType) {\n    super(request);\n    this.clientId = request.clientId;\n    this.clientSecret = request.clientSecret;\n    this.extraParams = request.extraParams;\n    this.scopes = request.scopes;\n  }\n\n  getHeaders(): Headers {\n    const headers: Headers = { 'Content-Type': 'application/x-www-form-urlencoded' };\n    if (typeof this.clientSecret !== 'undefined') {\n      // If client secret exists, it should be converted to base64\n      // https://tools.ietf.org/html/rfc6749#section-2.3.1\n      const encodedClientId = encodeURIComponent(this.clientId);\n      const encodedClientSecret = encodeURIComponent(this.clientSecret);\n      const credentials = `${encodedClientId}:${encodedClientSecret}`;\n      const basicAuth = Base64.encodeNoWrap(credentials);\n      headers.Authorization = `Basic ${basicAuth}`;\n    }\n\n    return headers;\n  }\n\n  async performAsync(discovery: Pick<ServiceConfig.DiscoveryDocument, 'tokenEndpoint'>) {\n    // redirect URI must not be nil\n    invariant(\n      discovery.tokenEndpoint,\n      `Cannot invoke \\`performAsync()\\` without a valid tokenEndpoint`\n    );\n    const response = await requestAsync<ServerTokenResponseConfig | ResponseErrorConfig>(\n      discovery.tokenEndpoint,\n      {\n        dataType: 'json',\n        method: 'POST',\n        headers: this.getHeaders(),\n        body: this.getQueryBody(),\n      }\n    );\n\n    if ('error' in response) {\n      throw new TokenError(response);\n    }\n\n    return new TokenResponse({\n      accessToken: response.access_token,\n      tokenType: response.token_type,\n      expiresIn: response.expires_in,\n      refreshToken: response.refresh_token,\n      scope: response.scope,\n      idToken: response.id_token,\n      issuedAt: response.issued_at,\n    });\n  }\n\n  getQueryBody() {\n    const queryBody: Record<string, string> = {\n      grant_type: this.grantType,\n    };\n\n    if (!this.clientSecret) {\n      // Only add the client ID if client secret is not present, otherwise pass the client id with the secret in the request body.\n      queryBody.client_id = this.clientId;\n    }\n\n    if (this.scopes) {\n      queryBody.scope = this.scopes.join(' ');\n    }\n\n    if (this.extraParams) {\n      for (const extra in this.extraParams) {\n        if (extra in this.extraParams && !(extra in queryBody)) {\n          queryBody[extra] = this.extraParams[extra];\n        }\n      }\n    }\n    return queryBody;\n  }\n}\n\n/**\n * Access token request. Exchange an authorization code for a user access token.\n *\n * [Section 4.1.3](https://tools.ietf.org/html/rfc6749#section-4.1.3)\n */\nexport class AccessTokenRequest\n  extends TokenRequest<AccessTokenRequestConfig>\n  implements AccessTokenRequestConfig\n{\n  readonly code: string;\n  readonly redirectUri: string;\n\n  constructor(options: AccessTokenRequestConfig) {\n    invariant(\n      options.redirectUri,\n      `\\`AccessTokenRequest\\` requires a valid \\`redirectUri\\` (it must also match the one used in the auth request). Example: ${Platform.select(\n        {\n          web: 'https://yourwebsite.com/redirect',\n          default: 'myapp://redirect',\n        }\n      )}`\n    );\n\n    invariant(\n      options.code,\n      `\\`AccessTokenRequest\\` requires a valid authorization \\`code\\`. This is what's received from the authorization server after an auth request.`\n    );\n    super(options, GrantType.AuthorizationCode);\n    this.code = options.code;\n    this.redirectUri = options.redirectUri;\n  }\n\n  getQueryBody() {\n    const queryBody: Record<string, string> = super.getQueryBody();\n\n    if (this.redirectUri) {\n      queryBody.redirect_uri = this.redirectUri;\n    }\n\n    if (this.code) {\n      queryBody.code = this.code;\n    }\n\n    return queryBody;\n  }\n\n  getRequestConfig() {\n    return {\n      clientId: this.clientId,\n      clientSecret: this.clientSecret,\n      grantType: this.grantType,\n      code: this.code,\n      redirectUri: this.redirectUri,\n      extraParams: this.extraParams,\n      scopes: this.scopes,\n    };\n  }\n}\n\n/**\n * Refresh request.\n *\n * [Section 6](https://tools.ietf.org/html/rfc6749#section-6)\n */\nexport class RefreshTokenRequest\n  extends TokenRequest<RefreshTokenRequestConfig>\n  implements RefreshTokenRequestConfig\n{\n  readonly refreshToken?: string;\n\n  constructor(options: RefreshTokenRequestConfig) {\n    invariant(options.refreshToken, `\\`RefreshTokenRequest\\` requires a valid \\`refreshToken\\`.`);\n    super(options, GrantType.RefreshToken);\n    this.refreshToken = options.refreshToken;\n  }\n\n  getQueryBody() {\n    const queryBody = super.getQueryBody();\n\n    if (this.refreshToken) {\n      queryBody.refresh_token = this.refreshToken;\n    }\n\n    return queryBody;\n  }\n\n  getRequestConfig() {\n    return {\n      clientId: this.clientId,\n      clientSecret: this.clientSecret,\n      grantType: this.grantType,\n      refreshToken: this.refreshToken,\n      extraParams: this.extraParams,\n      scopes: this.scopes,\n    };\n  }\n}\n\n/**\n * Revocation request for a given token.\n *\n * [Section 2.1](https://tools.ietf.org/html/rfc7009#section-2.1)\n */\nexport class RevokeTokenRequest\n  extends Request<RevokeTokenRequestConfig, boolean>\n  implements RevokeTokenRequestConfig\n{\n  readonly clientId?: string;\n  readonly clientSecret?: string;\n  readonly token: string;\n  readonly tokenTypeHint?: TokenTypeHint;\n\n  constructor(request: RevokeTokenRequestConfig) {\n    super(request);\n    invariant(request.token, `\\`RevokeTokenRequest\\` requires a valid \\`token\\` to revoke.`);\n    this.clientId = request.clientId;\n    this.clientSecret = request.clientSecret;\n    this.token = request.token;\n    this.tokenTypeHint = request.tokenTypeHint;\n  }\n\n  getHeaders(): Headers {\n    const headers: Headers = { 'Content-Type': 'application/x-www-form-urlencoded' };\n    if (typeof this.clientSecret !== 'undefined' && this.clientId) {\n      // If client secret exists, it should be converted to base64\n      // https://tools.ietf.org/html/rfc6749#section-2.3.1\n      const encodedClientId = encodeURIComponent(this.clientId);\n      const encodedClientSecret = encodeURIComponent(this.clientSecret);\n      const credentials = `${encodedClientId}:${encodedClientSecret}`;\n      const basicAuth = Base64.encodeNoWrap(credentials);\n      headers.Authorization = `Basic ${basicAuth}`;\n    }\n\n    return headers;\n  }\n\n  /**\n   * Perform a token revocation request.\n   *\n   * @param discovery The `revocationEndpoint` for a provider.\n   */\n  async performAsync(discovery: Pick<ServiceConfig.DiscoveryDocument, 'revocationEndpoint'>) {\n    invariant(\n      discovery.revocationEndpoint,\n      `Cannot invoke \\`performAsync()\\` without a valid revocationEndpoint`\n    );\n    await requestAsync<boolean>(discovery.revocationEndpoint, {\n      method: 'POST',\n      headers: this.getHeaders(),\n      body: this.getQueryBody(),\n    });\n\n    return true;\n  }\n\n  getRequestConfig() {\n    return {\n      clientId: this.clientId,\n      clientSecret: this.clientSecret,\n      token: this.token,\n      tokenTypeHint: this.tokenTypeHint,\n    };\n  }\n\n  getQueryBody(): Record<string, string> {\n    const queryBody: Record<string, string> = { token: this.token };\n    if (this.tokenTypeHint) {\n      queryBody.token_type_hint = this.tokenTypeHint;\n    }\n    // Include client creds https://tools.ietf.org/html/rfc6749#section-2.3.1\n    if (this.clientId) {\n      queryBody.client_id = this.clientId;\n    }\n    if (this.clientSecret) {\n      queryBody.client_secret = this.clientSecret;\n    }\n    return queryBody;\n  }\n}\n\n/**\n * Exchange an auth code for an access token that can be used to get data from the provider.\n *\n * @param config\n * @param discovery The `tokenEndpoint` for a provider.\n */\nexport function exchangeCodeAsync(\n  config: AccessTokenRequestConfig,\n  discovery: Pick<ServiceConfig.DiscoveryDocument, 'tokenEndpoint'>\n): Promise<TokenResponse> {\n  const request = new AccessTokenRequest(config);\n  return request.performAsync(discovery);\n}\n\n/**\n * Refresh an access token. Often this just requires the `refreshToken` and `scopes` parameters.\n *\n * [Section 6](https://tools.ietf.org/html/rfc6749#section-6)\n *\n * @param config\n * @param discovery The `tokenEndpoint` for a provider.\n */\nexport function refreshAsync(\n  config: RefreshTokenRequestConfig,\n  discovery: Pick<ServiceConfig.DiscoveryDocument, 'tokenEndpoint'>\n): Promise<TokenResponse> {\n  const request = new RefreshTokenRequest(config);\n  return request.performAsync(discovery);\n}\n\n/**\n * Revoke a token with a provider.\n * This makes the token unusable, effectively requiring the user to login again.\n *\n * @param config\n * @param discovery The `revocationEndpoint` for a provider.\n */\nexport function revokeAsync(\n  config: RevokeTokenRequestConfig,\n  discovery: Pick<ServiceConfig.DiscoveryDocument, 'revocationEndpoint'>\n): Promise<boolean> {\n  const request = new RevokeTokenRequest(config);\n  return request.performAsync(discovery);\n}\n\n/**\n * Fetch generic user info from the provider's OpenID Connect `userInfoEndpoint` (if supported).\n *\n * [UserInfo](https://openid.net/specs/openid-connect-core-1_0.html#UserInfo)\n *\n * @param config The `accessToken` for a user, returned from a code exchange or auth request.\n * @param discovery The `userInfoEndpoint` for a provider.\n */\nexport function fetchUserInfoAsync(\n  config: Pick<TokenResponse, 'accessToken'>,\n  discovery: Pick<ServiceConfig.DiscoveryDocument, 'userInfoEndpoint'>\n): Promise<Record<string, any>> {\n  if (!discovery.userInfoEndpoint) {\n    throw new Error('User info endpoint is not defined in the service config discovery document');\n  }\n  return requestAsync<Record<string, any>>(discovery.userInfoEndpoint, {\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      Authorization: `Bearer ${config.accessToken}`,\n    },\n    dataType: 'json',\n    method: 'GET',\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}