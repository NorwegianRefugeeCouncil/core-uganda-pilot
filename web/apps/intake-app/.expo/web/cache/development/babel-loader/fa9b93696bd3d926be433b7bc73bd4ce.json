{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _wrapNativeSuper from \"@babel/runtime/helpers/wrapNativeSuper\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport { UnavailabilityError } from 'expo-modules-core';\nimport { CryptoDigestAlgorithm, CryptoEncoding } from \"./Crypto.types\";\nimport ExpoCrypto from \"./ExpoCrypto\";\nexport * from \"./Crypto.types\";\n\nvar CryptoError = function (_TypeError) {\n  _inherits(CryptoError, _TypeError);\n\n  var _super = _createSuper(CryptoError);\n\n  function CryptoError(message) {\n    var _this;\n\n    _classCallCheck(this, CryptoError);\n\n    _this = _super.call(this, \"expo-crypto: \" + message);\n    _this.code = 'ERR_CRYPTO';\n    return _this;\n  }\n\n  return CryptoError;\n}(_wrapNativeSuper(TypeError));\n\nfunction assertAlgorithm(algorithm) {\n  if (!Object.values(CryptoDigestAlgorithm).includes(algorithm)) {\n    throw new CryptoError(\"Invalid algorithm provided. Expected one of: CryptoDigestAlgorithm.\" + Object.keys(CryptoDigestAlgorithm).join(', AlgCryptoDigestAlgorithmorithm.'));\n  }\n}\n\nfunction assertData(data) {\n  if (typeof data !== 'string') {\n    throw new CryptoError(\"Invalid data provided. Expected a string.\");\n  }\n}\n\nfunction assertEncoding(encoding) {\n  if (!Object.values(CryptoEncoding).includes(encoding)) {\n    throw new CryptoError(\"Invalid encoding provided. Expected one of: CryptoEncoding.\" + Object.keys(CryptoEncoding).join(', CryptoEncoding.'));\n  }\n}\n\nexport function digestStringAsync(algorithm, data) {\n  var options,\n      _args = arguments;\n  return _regeneratorRuntime.async(function digestStringAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {\n            encoding: CryptoEncoding.HEX\n          };\n\n          if (ExpoCrypto.digestStringAsync) {\n            _context.next = 3;\n            break;\n          }\n\n          throw new UnavailabilityError('expo-crypto', 'digestStringAsync');\n\n        case 3:\n          assertAlgorithm(algorithm);\n          assertData(data);\n          assertEncoding(options.encoding);\n          _context.next = 8;\n          return _regeneratorRuntime.awrap(ExpoCrypto.digestStringAsync(algorithm, data, options));\n\n        case 8:\n          return _context.abrupt(\"return\", _context.sent);\n\n        case 9:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}","map":{"version":3,"sources":["../src/Crypto.ts"],"names":[],"mappings":";;;;;;;;;;;AAAA,SAAS,mBAAT,QAAoC,mBAApC;AAEA,SAAS,qBAAT,EAAgC,cAAhC;AACA,OAAO,UAAP;AAEA;;IAEM,W;;;;;AAGJ,uBAAY,OAAZ,EAA2B;AAAA;;AAAA;;AACzB,gDAAsB,OAAtB;AADyB,UAF3B,IAE2B,GAFpB,YAEoB;AAAA;AAE1B;;;mBALuB,S;;AAQ1B,SAAS,eAAT,CAAyB,SAAzB,EAAyD;AACvD,MAAI,CAAC,MAAM,CAAC,MAAP,CAAc,qBAAd,EAAqC,QAArC,CAA8C,SAA9C,CAAL,EAA+D;AAC7D,UAAM,IAAI,WAAJ,yEACkE,MAAM,CAAC,IAAP,CACpE,qBADoE,EAEpE,IAFoE,CAE/D,mCAF+D,CADlE,CAAN;AAKD;AACF;;AAED,SAAS,UAAT,CAAoB,IAApB,EAAgC;AAC9B,MAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;AAC5B,UAAM,IAAI,WAAJ,6CAAN;AACD;AACF;;AAED,SAAS,cAAT,CAAwB,QAAxB,EAAgD;AAC9C,MAAI,CAAC,MAAM,CAAC,MAAP,CAAc,cAAd,EAA8B,QAA9B,CAAuC,QAAvC,CAAL,EAAuD;AACrD,UAAM,IAAI,WAAJ,iEAC0D,MAAM,CAAC,IAAP,CAC5D,cAD4D,EAE5D,IAF4D,CAEvD,mBAFuD,CAD1D,CAAN;AAKD;AACF;;AAED,OAAO,SAAe,iBAAf,CACL,SADK,EAEL,IAFK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGL,UAAA,OAHK,2DAG0B;AAAE,YAAA,QAAQ,EAAE,cAAc,CAAC;AAA3B,WAH1B;;AAAA,cAKA,UAAU,CAAC,iBALX;AAAA;AAAA;AAAA;;AAAA,gBAMG,IAAI,mBAAJ,CAAwB,aAAxB,EAAuC,mBAAvC,CANH;;AAAA;AASL,UAAA,eAAe,CAAC,SAAD,CAAf;AACA,UAAA,UAAU,CAAC,IAAD,CAAV;AACA,UAAA,cAAc,CAAC,OAAO,CAAC,QAAT,CAAd;AAXK;AAAA,2CAaQ,UAAU,CAAC,iBAAX,CAA6B,SAA7B,EAAwC,IAAxC,EAA8C,OAA9C,CAbR;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA","sourcesContent":["import { UnavailabilityError } from 'expo-modules-core';\n\nimport { CryptoDigestAlgorithm, CryptoEncoding, CryptoDigestOptions, Digest } from './Crypto.types';\nimport ExpoCrypto from './ExpoCrypto';\n\nexport * from './Crypto.types';\n\nclass CryptoError extends TypeError {\n  code = 'ERR_CRYPTO';\n\n  constructor(message: string) {\n    super(`expo-crypto: ${message}`);\n  }\n}\n\nfunction assertAlgorithm(algorithm: CryptoDigestAlgorithm): void {\n  if (!Object.values(CryptoDigestAlgorithm).includes(algorithm)) {\n    throw new CryptoError(\n      `Invalid algorithm provided. Expected one of: CryptoDigestAlgorithm.${Object.keys(\n        CryptoDigestAlgorithm\n      ).join(', AlgCryptoDigestAlgorithmorithm.')}`\n    );\n  }\n}\n\nfunction assertData(data: string): void {\n  if (typeof data !== 'string') {\n    throw new CryptoError(`Invalid data provided. Expected a string.`);\n  }\n}\n\nfunction assertEncoding(encoding: CryptoEncoding): void {\n  if (!Object.values(CryptoEncoding).includes(encoding)) {\n    throw new CryptoError(\n      `Invalid encoding provided. Expected one of: CryptoEncoding.${Object.keys(\n        CryptoEncoding\n      ).join(', CryptoEncoding.')}`\n    );\n  }\n}\n\nexport async function digestStringAsync(\n  algorithm: CryptoDigestAlgorithm,\n  data: string,\n  options: CryptoDigestOptions = { encoding: CryptoEncoding.HEX }\n): Promise<Digest> {\n  if (!ExpoCrypto.digestStringAsync) {\n    throw new UnavailabilityError('expo-crypto', 'digestStringAsync');\n  }\n\n  assertAlgorithm(algorithm);\n  assertData(data);\n  assertEncoding(options.encoding);\n\n  return await ExpoCrypto.digestStringAsync(algorithm, data, options);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}