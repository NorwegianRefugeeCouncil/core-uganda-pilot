package vulnerability

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/gorilla/mux"
	"github.com/nrc-no/core-kafka/pkg/expressions"
	i81n "github.com/nrc-no/core-kafka/pkg/i81n/api/v1"
	"github.com/nrc-no/core-kafka/pkg/services/api"
	api2 "github.com/nrc-no/core-kafka/pkg/subjects/api"
	uuid "github.com/satori/go.uuid"
	"github.com/sirupsen/logrus"
	"io/ioutil"
	"net/http"
)

type Handler struct {
	store  *Store
	router *mux.Router
}

func NewHandler(store *Store) *Handler {
	h := &Handler{
		store: store,
	}
	router := mux.NewRouter()
	router.Path("/apis/v1/vulnerabilities").Methods("POST").HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
		h.PostVulnerability(w, req)
	})
	router.Path("/apis/v1/vulnerabilities").Methods("GET").HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
		h.ListVulnerabilities(w, req)
	})
	h.router = router
	return h
}

type PostVulnerability struct {
	Name                       string                `json:"name"`
	SubjectType                api2.SubjectType      `json:"subjectType"`
	ValueType                  expressions.ValueType `json:"valueType"`
	LongFormulation            i81n.Translations     `json:"longFormulation"`
	ShortFormulation           i81n.Translations     `json:"shortFormulation"`
	AttributesForDetermination []string              `json:"attributesForDetermination"`
}

func (h *Handler) PostVulnerability(w http.ResponseWriter, req *http.Request) {

	ctx := req.Context()

	bodyBytes, err := ioutil.ReadAll(req.Body)
	if err != nil {
		h.logError(ctx, err, "failed to read request body")
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	var payload PostVulnerability
	if err := json.Unmarshal(bodyBytes, &payload); err != nil {
		h.logError(ctx, err, "failed to unmarshal vulnerability")
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	vulnerability := api.Vulnerability{
		ID:                         uuid.NewV4().String(),
		Name:                       payload.Name,
		SubjectType:                payload.SubjectType,
		ValueType:                  payload.ValueType,
		LongFormulation:            payload.LongFormulation,
		ShortFormulation:           payload.ShortFormulation,
		AttributesForDetermination: payload.AttributesForDetermination,
	}

	vulnerabilityJson, err := json.Marshal(vulnerability)
	if err != nil {
		h.logError(ctx, err, "failed to marshal vulnerability")
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	if err := h.store.Create(ctx, &vulnerability); err != nil {
		h.logError(ctx, err, "failed to store vulnerability")
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.Write(vulnerabilityJson)

}

type UpdateVulnerability struct {
	ValueType                  *expressions.ValueType `json:"valueType"`
	LongFormulation            *i81n.Translations     `json:"longFormulation"`
	ShortFormulation           *i81n.Translations     `json:"shortFormulation"`
	AttributesForDetermination []string               `json:"attributesForDetermination"`
}

func (h *Handler) UpdateVulnerability(w http.ResponseWriter, req *http.Request) {

	ctx := req.Context()

	id, ok := mux.Vars(req)["id"]
	if !ok || len(id) == 0 {
		err := fmt.Errorf("no id in path")
		h.logError(ctx, err, "failed retrieve vulnerability")
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	v, err := h.store.Get(ctx, id)
	if err != nil {
		h.logError(ctx, err, "failed retrieve vulnerability")
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	bodyBytes, err := ioutil.ReadAll(req.Body)
	if err != nil {
		h.logError(ctx, err, "failed to read request body")
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	var payload UpdateVulnerability
	if err := json.Unmarshal(bodyBytes, &payload); err != nil {
		h.logError(ctx, err, "failed to unmarshal vulnerability")
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	if payload.ValueType != nil {
		v.ValueType = *payload.ValueType
	}
	if payload.LongFormulation != nil {
		v.LongFormulation = *payload.LongFormulation
	}
	if payload.ShortFormulation != nil {
		v.ShortFormulation = *payload.ShortFormulation
	}
	if payload.AttributesForDetermination != nil {
		v.AttributesForDetermination = payload.AttributesForDetermination
	}

	if err := h.store.Update(ctx, v); err != nil {
		h.logError(ctx, err, "failed to update vulnerability")
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	responseBytes, err := json.Marshal(v)
	if err != nil {
		h.logError(ctx, err, "failed to marshal vulnerability")
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.Write(responseBytes)

}

func (h *Handler) ListVulnerabilities(w http.ResponseWriter, req *http.Request) {

	ctx := req.Context()

	vulnerabilities, err := h.store.GetAll(ctx)
	if err != nil {
		h.logError(ctx, err, "failed to list vulnerabilities")
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	list := api.VulnerabilityList{}
	list.Items = vulnerabilities

	responseBytes, err := json.Marshal(list)
	if err != nil {
		h.logError(ctx, err, "failed to marshal vulnerabilities")
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.Write(responseBytes)

}

func (h *Handler) GetVulnerability(w http.ResponseWriter, req *http.Request) {

	ctx := req.Context()

	vars := mux.Vars(req)
	id, ok := vars["id"]
	if !ok {
		h.logError(ctx, fmt.Errorf("no id in path"), "failed to get vulnerability id from path")
		http.Error(w, "could not get vulnerability id", http.StatusInternalServerError)
		return
	}

	v, err := h.store.Get(ctx, id)
	if err != nil {
		h.logError(ctx, err, "failed to get vulnerability")
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	jsonBytes, err := json.Marshal(v)
	if err != nil {
		h.logError(ctx, err, "failed to marshal vulnerability")
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.Write(jsonBytes)
}

func (h *Handler) log(ctx context.Context) *logrus.Entry {
	return logrus.WithContext(ctx).WithField("handler", "Vulnerability")
}

func (h *Handler) logError(ctx context.Context, err error, message string, args ...interface{}) {
	h.log(ctx).WithError(err).Errorf(message, args...)
}

func (h *Handler) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	h.router.ServeHTTP(w, req)
}
